task_description: |
  Task: Build a paginated task search endpoint (GET /api/tasks/search)
  Instructions:
    Right now the backend gives you a simple list endpoint at `GET /api/tasks`.
    It can return all tasks, and with the work from an earlier task it can also
    filter by status. That is fine for small datasets, but it does not scale
    very well once you have dozens or hundreds of tasks.

    In this task you will introduce a **separate** read-only endpoint that is
    designed for a more realistic UI: it should support pagination, optional
    filtering by status, and basic sorting. The idea is to give the frontend a
    single endpoint that feels pleasant to work with when building real task
    list screens.

    New endpoint to implement:
      - HTTP method: `GET`
      - Route: `/api/tasks/search`

    Query parameters:
      - `page` (optional, integer):
          - 1-based page index.
          - Defaults to 1 when missing or not provided.
      - `pageSize` (optional, integer):
          - Number of items per page.
          - Defaults to 10 when missing.
          - Must be at least 1 and no more than 50. Values outside that range
            should be rejected with a 400 response.
      - `status` (optional, string):
          - When present, must be one of the existing allowed statuses:
            `pending`, `in-progress`, `completed`.
          - If provided with any other value, the endpoint should return a 400
            response with a clear JSON error message.
      - `sortBy` (optional, string):
          - Which field to sort by.
          - Supported values: `createdAt`, `title`, `status`.
          - Defaults to `createdAt`.
      - `sortDirection` (optional, string):
          - Sort direction for the field selected by `sortBy`.
          - Supported values: `asc`, `desc`.
          - Defaults to `desc`.

    Response shape:
      The endpoint should respond with a JSON object that separates the list of
      tasks from the pagination metadata. A successful 200 response must look
      like this:

        {
          "items": [
            { /* Task document */ },
            { /* Task document */ }
          ],
          "meta": {
            "page": 1,
            "pageSize": 10,
            "totalItems": 23,
            "totalPages": 3,
            "hasNextPage": true,
            "hasPreviousPage": false
          }
        }

      Notes on behaviour:
        - `items` should contain only the tasks for the requested page.
        - `totalItems` is the total number of tasks matching the filter
          (including all pages).
        - `totalPages` is the number of pages based on `totalItems` and
          `pageSize` (use ceiling division).
        - `hasNextPage` is true when there is another page after the current
          one.
        - `hasPreviousPage` is true when the current page is greater than 1.
        - If the requested `page` is beyond the last page, `items` may be an
          empty list, but the `meta` information should still be accurate.

    Implementation guidance:
      - Add a new controller function in `backend/controllers/taskController.js`
        (for example, `searchTasks`).
      - Wire it up in `backend/routes/tasks.js` under the `/search` path so the
        full route becomes `/api/tasks/search`.
      - Reuse the existing `Task` model and the `ALLOWED_STATUSES` helper
        constant that already lives in the controller.
      - Use Mongoose queries with `skip`, `limit`, and `sort` to implement the
        pagination and ordering. You should still perform a separate
        `countDocuments` query (with the same filter) so that the pagination
        metadata is correct.
      - When query parameters are missing, fall back to the defaults described
        above instead of returning errors.
      - When query parameters are present but invalid (for example, a negative
        page number or an unsupported `sortBy` field), return a 400 response
        with a JSON body that includes a short human-readable error message.

    How this will be tested:
      - The tests will spin up MongoDB and the backend in Docker the same way
        as the previous tasks.
      - They will insert a small set of tasks with different titles and
        statuses using `POST /api/tasks`.
      - Then they will call `GET /api/tasks/search` with different combinations
        of query parameters and check:
          - That pagination metadata is correct.
          - That invalid input is rejected with a 400.
          - That sorting and filtering behave as described.

    What to be careful about:
      - Do not change the behaviour of the existing `/api/tasks` endpoints.
        This new search route should be additive.
      - Try to keep the controller code readable. Small helper functions for
        validating or normalising query parameters are perfectly fine if they
        make the logic clearer.

    Overall, think of this feature as something you would be comfortable
    handing to a frontend teammate who is building a real task dashboard. The
    more predictable and well-structured the JSON shape is, the nicer their
    life becomes.

difficulty: hard
category: Feature
tags: [node, express, mongodb, backend, pagination]
parser_name: pytest

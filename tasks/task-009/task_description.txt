task_description: |
  Task: Add lightweight labels to tasks (PATCH /api/tasks/:id/labels, GET /api/tasks?label=...)
  Instructions:
    At this point, tasks have titles, descriptions, status, archive state, and
    optional due dates. That is already quite a bit of structure, but in
    practice people often want a looser way to group tasks: quick labels like
    "frontend", "backend", or "urgent" that can be added and removed over time.

    In this task you will add a simple **labels** feature. Each task will gain
    an array of strings called `labels`, along with a dedicated endpoint for
    updating that array and an optional filter on the main listing route.

    1. Extend the Task model with labels

      - In `backend/models/Task.js`, add a new field to the schema:

          labels: string[]

        - Type: array of strings.
        - Default: empty array `[]`.
        - Trimming/casing rules:
          - You do not need to enforce any particular case (upper/lower), but
            you should trim leading/trailing whitespace from label strings.

    2. New endpoint: replace labels for a task

      - HTTP method: `PATCH`
      - Route: `/api/tasks/:id/labels`

      Request body:
        - JSON object with a single required field:

            {
              "labels": ["frontend", "urgent"]
            }

        - Validation rules for `labels`:
          - Must be present.
          - Must be an array.
          - Every element in the array must be a string.
          - After trimming, labels that end up as empty strings should be
            discarded.
          - Duplicates should be removed so that the stored list contains each
            label at most once.

      Behaviour:
        - If `:id` is not a valid MongoDB ObjectId:
          - Return HTTP 400 with a JSON body containing a `message` field.

        - If `:id` is valid but no task with that id exists:
          - Return HTTP 404 with a JSON body containing a `message` field.

        - If `labels` is missing, not an array, or contains non-string
          elements:
          - Return HTTP 400 with a JSON body containing a `message` field.

        - On success:
          - Replace the taskâ€™s `labels` array with the cleaned-up list
            (trimmed, empty strings removed, duplicates removed).
          - Return HTTP 200 with the updated task document as JSON.

    3. Label filter on the main listing endpoint

      - Extend the existing `GET /api/tasks` controller so that it supports an
        optional `label` query parameter:

          GET /api/tasks?label=frontend

      - When `label` is provided:
        - The endpoint should only return tasks whose `labels` array contains
          that label **exactly** (after whatever trimming/casing logic you use
          when storing labels).
        - The behaviour of other query parameters (such as `status` and
          `includeArchived`) should still apply on top of this filter.

      - When `label` is not provided, the endpoint should behave exactly as it
        does today, ignoring labels for the default listing.

    4. Implementation notes

      - Update `backend/models/Task.js` to add the `labels` field with a
        default of `[]`.
      - Add a new controller function in `backend/controllers/taskController.js`
        (for example, `updateTaskLabels`) to implement the
        `PATCH /api/tasks/:id/labels` logic described above.
      - Update the existing `getTasks` controller to:
        - Read an optional `label` query parameter.
        - When present, add a condition to the MongoDB query so that only tasks
          containing that label are returned.
      - Wire the new labels controller into `backend/routes/tasks.js` under the
        `/labels` path so that the full route becomes
        `/api/tasks/:id/labels`.
      - Reuse the existing error-handling patterns (400 for invalid ids,
        404 for missing tasks, etc.) so that the new endpoint feels like a
        natural part of the existing API.

    5. How this will be tested

      - The tests for this task will spin up MongoDB and the backend via a
        task-local `docker-compose.yaml`, in the same style as the earlier
        tasks.
      - They will:
        - Create tasks with and without labels.
        - Use `PATCH /api/tasks/:id/labels` to set and replace labels.
        - Call `GET /api/tasks?label=...` and confirm that only tasks with the
          given label are returned.
        - Verify that invalid ids, invalid `labels` payloads, and label
          duplicates/empty values are handled according to the rules above.

    Think of this feature as a very small, flexible tagging system. It should
    be easy to build a "Filter by label" UI on top of it and easy to maintain
    when reading the backend code.

difficulty: hard
category: Feature
tags: [node, express, mongodb, backend, tags]
parser_name: pytest

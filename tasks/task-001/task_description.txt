task_description: |
	Task: Implement a real Task API on top of the existing skeleton
	Instructions:
	  You already have a bare-bones MERN scaffold in place. The backend knows about a
	  Task model, there are placeholder controller functions, and the /api/tasks routes
	  are wired up. Right now, though, the API never actually talks to MongoDB and none
	  of the usual edge cases are handled.

	  This first task is about turning that sketch into a small but honest REST API for
	  tasks. Think of it as picking up after a developer who roughed in the idea late
	  one evening and then never circled back to finish it.

	  You will work only in the backend for this task. The main goal is to implement
	  real CRUD behaviour for /api/tasks using MongoDB through Mongoose.

	  The existing routes are:
	    - GET /api/tasks
	    - POST /api/tasks
	    - PUT /api/tasks/:id
	    - DELETE /api/tasks/:id

	  These routes are currently wired to placeholder controller functions in
	  backend/controllers/taskController.js. Your job is to replace those placeholders
	  with real logic that talks to the Task model defined in backend/models/Task.js.

	  At a high level, the API behaviour should look like this:

	  1. Create a task
	     - POST /api/tasks should accept a JSON payload with at least title and,
	       optionally, description and status.
	     - title must be a non-empty string once trimmed. If it is missing or only
	       whitespace, the endpoint should reply with HTTP 400 and a clear validation
	       message.
	     - If status is omitted, it should default to "pending" (this matches the
	       schema, and your controller should behave in a way that does not surprise
	       anyone).
	     - On success, return HTTP 201 and the newly created task document as JSON.

	  2. List tasks
	     - GET /api/tasks should return an array of all tasks stored in MongoDB.
	     - The ordering should be predictable: for this task, treat "newest first"
	       as the default. Use createdAt (from the Mongoose timestamps) to sort in
	       descending order.
	     - The response should be a plain JSON array; there is no need to wrap it in
	       an extra object.

	  3. Update a task
	     - PUT /api/tasks/:id should update the existing task with the given MongoDB
	       _id.
	     - Handle partial updates from the body (title, description, status) and avoid
	       silently accepting obviously wrong values.
	     - If the id does not correspond to an existing task, return HTTP 404 with a
	       short explanation.
	     - If the update payload is structurally wrong (for example, status is not one
	       of "pending", "in-progress", or "completed"), return HTTP 400.
	     - On success, respond with the updated task document.

	  4. Delete a task
	     - DELETE /api/tasks/:id should remove the task if it exists.
	     - If the task does not exist, return HTTP 404 instead of pretending that
	       everything was fine.
	     - On success, return a simple JSON object confirming the deletion, along with
	       the id that was removed.

	  Error handling and edge cases
	  -----------------------------
	  You do not need to build a full-blown global error handler for this task, but
	  you should be disciplined about the obvious issues:

	  - Distinguish between bad input (400), not found (404), and unexpected failures
	    (500).
	  - Do not leak raw database errors directly to the client. A one-line,
	    human-readable summary is enough.
	  - Be careful with invalid ObjectIds passed in :id. Mongoose will complain if you
	    feed it garbage. Handling that and turning it into a 400 is part of the
	    challenge.

	  How the tests see your work
	  ---------------------------
	  The task_tests.js file in this folder is written from the perspective of a
	  slightly grumpy backend engineer. It assumes your backend is already running on
	  http://localhost:5000 and that MongoDB is reachable, either locally or through
	  the provided docker-compose.yaml.

	  The tests will:
	  - Try to create valid tasks and expect consistent responses.
	  - Reject obviously invalid payloads.
	  - Check that listing tasks returns them in the right order.
	  - Verify that updates and deletes behave sensibly and that ids that do not exist
	    are handled with proper status codes.

	  Frontend changes are not part of this task. The UI will still be serving static
	  placeholder content for now. The only thing that matters here is that the HTTP
	  contract between the tests and your backend is honoured.

	  How to run the tests
	  --------------------
	  You have two main options, depending on how you prefer to work:

	  1. Use your local Node and MongoDB setup
	     - From the project root, start MongoDB however you normally do.
	     - In a separate terminal, go to backend/, install dependencies if you have
	       not already, and start the server:
	         - npm install
	         - npm run dev
	     - Once the backend is running on port 5000, come back to this folder and
	       run:
	         - ./run-tests.sh

	  2. Use the provided Docker Compose file
	     - Make sure Docker is running on your machine.
	     - From this task's directory, run:
	         - docker-compose up --build
	     - Give it a bit of time to install dependencies and bring up both MongoDB
	       and the backend.
	     - In another shell, run the tests from this directory:
	         - ./run-tests.sh

	  The tests are intentionally a bit unforgiving. If something fails, read the
	  assertion messages closely; they were written to hint at what is missing without
	  spelling out the entire solution.

	  The aim of this task is not to write the most clever code in the world. A
	  straightforward implementation that passes all the tests and is pleasant to
	  read is exactly what you should be aiming for.

difficulty: hard
category: Feature
tags: [node, backend, api]
parser_name: node

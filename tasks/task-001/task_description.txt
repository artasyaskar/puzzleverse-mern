task_description: |
  Task: Make a real working login system for the MERN starter
  Instructions:
  You are the engineer now. You have to make a real, safe login system. Think of it like making a front door, a guard who checks people, and a book that remembers who came in. Everything should work well and not break.

  What you’ll build (server-side, Node/Express):
  - A small user list saved in memory. Each user has: id, email, passwordHash, createdAt.
  - Passwords must be changed into a strong hash (bcrypt or argon2). Never save real passwords.
  - Routes under /api/auth:
    - POST /register: make a new user. Do not allow same email two times (email check should ignore upper/lower case). Check if email is valid and password has at least 8 letters, with one letter and one number. On success return { id, email }, status 201.
    - POST /login: check email and password. If correct, give:
      - a short-time access token (JWT), and
      - a long-time refresh token (a random string).
      Return { accessToken, refreshToken, user: { id, email } }, status 200.
    - POST /refresh: take a good refresh token and give a new access token. Refresh tokens should be used only once and replaced with a new one. Return { accessToken, refreshToken }.
    - POST /logout: remove the given refresh token so it can’t be used again. If the token is already gone, still return OK.
  - Protected sample route:
    - GET /api/me: needs a good access token (Authorization: Bearer <token>). Returns { id, email } of the logged-in user.
  - Rate limiting:
    - For POST /login only: allow only 5 tries from one IP in 60 seconds. If someone tries more, return 429 with a friendly message.
  - Validation & errors:
    - If input is wrong, return 400 with a simple, clear message.
    - If login or token is wrong, return 401.
    - If too many tries, return 429.

  Important behaviors the tests need:
  - Emails are checked without caring about letter case for both signup and login.
  - Passwords must never be sent back in any reply.
  - Access tokens should have a short life (you can pretend 5 minutes). You only need to put this inside the token; no need to wait.
  - Refresh tokens are saved in memory and must change each time they are used. Old one becomes bad.
  - Logout removes the refresh token that was given, but does not break other tokens.

  Technical requirements:
  - Keep it simple: no database. Save users and refresh tokens in memory.
  - Keep files ordered in server/src:
    - server/src/auth/service.js: user storage, hashing, making/verifying/rotating/revoking tokens
    - server/src/auth/routes.js: express routes and checks for inputs
    - server/src/middleware/rateLimit.js: simple IP limit for /login
    - server/src/index.js: connect all routes and middleware
  - Use JWT for access tokens (HS256) with secret from process.env.JWT_SECRET (a safe default is allowed for tests).
  - Use strong password hashing (bcrypt or argon2). Pick one.
  - No UI changes needed.

  Success criteria (what passing looks like):
  - All tests in tasks/task-001/task_tests.py pass.
  - App should still build, and the health endpoint must work.
  - Code should be clean, easy to read, and handle the special cases above.

  Tips:
  - Be careful with status codes and messages; tests will check them.
  - Keep functions small and clear so they are easy to test.
  - Refresh tokens are private secrets. Do not print them.
  
difficulty: hard
category: Feature
tags: [node, express, auth]
parser_name: pytest
